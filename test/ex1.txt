/* ATTENTION: ce ficher n'a pour l'instant ete verifie que pour les aspects
 * lexicaux et syntaxiques.
 * Il peut subsister des erreurs contextuelles qui seront indiquees
 * ulterieurement.
 * Il sert principalement à donner des exemples des differentes
 * constructions.
 * Les resultats donnés à l'exécution seront precises ulterieurement aussi.
 */
object CptPoint is           /* Compteur d'instances de Point */
{ var next : Integer := 1;   /* index de la prochaine instance de Point */
  def incr() : Integer is { result := next; next := next + 1;}
  def howMany() : Integer := next - 1
}

class Point(var x: Integer, var y: Integer := 0, var name: String := "")
      { CptPoint.incr(); } is
{ var hasClone : Integer := 0;   /* attributs supplementaires */
  /* la valeur du champ ci-dessous est indefinie si hasClone vaut 0.
   * Le probleme est qu'on n'a pas l'equivalent de NULL (du bon type)
   * dans le langage. On ne peut pas utiliser un 'object' pour cela car
   * un objet n'a pas de type defini.
  */
  var clone : Point;

  def setName(s: String) is { name := s; }

  def getx() : Integer := this.x      /* pas de this implicite */

  def gety() : Integer := this.y

  def cloned() : Integer := hasClone <> 0

  def move(dx: Integer, dy: Integer, verbose: Integer := 0) is {
      x := x + dx; y := y + dy;
      if verbose then { this.print(); } else {}
  }

  def print(verbose : Integer := 0 ) is {
      if verbose then "Inside Point::print".println(); else { }
      /* Exemples avec l'operateur & de concatenation de chaines */
      name.print();
      ( "= (" & x.toString() & ", " & y.toString() & ")" ).println();
  }

  /* par defaut, on ajoute un ' au nom de l'objet. On pourra le changer
   * avec setName
   */
  def clone() : Point is
  { this.clone = 1;
    /* On memorise le dernier clone construit à partir de cet objet */
    this.clone := new Point(x, y, this.name & "'");
    result := this.clone;
  }

  /* imprime le clone de cet objet, s'il existe, ainsi que recursivement
   * les clones de ce dernier
   */
  def allClones () is {
    if hasClone <> 0 then { this.print(); this.clone.allClones(); }
    else { }
  }

  def egal(p: Point) : Integer is {
   /* ils sont egaux s'ils ont memes coordonnees */
       var b1 : Integer := p.x - x;
       var b2 : Integer := p.y - y;
       is
       if b1 then result := 0; else result := b2 = 0;
  }

  def egal2(p: Point) : Integer is {  /* autre version */
    var b1 : Integer := p.x - x;
    var b2: Integer;
    is
    result := 0;
    if b1 then { return; } else { }
       b2 := p.y - y;
       result := b2 = 0;
  }
}

class Couleur(var coul: Integer := 0)
   /* 3 couleurs : couleur = 0, 1 ou 2
    * Valeur initiale a 0 par defaut mais modifiable en passant un argument
    * explicitement. Le corps du constructeur garantit qu'on a bien que
    * trois couleurs.
    */
  { if coul < 0 then coul := 0;
    else if coul > 2 then coul := 0; else {}
  }
 is
 {
  def name(verbose: Integer := 0) : String is {
      var aux : String;
      is
      if verbose then "Inside Couleur::couleur".println(); else {}
      if coul = 0 then result:= "Blanc";
      else { var dummy : String; is
             if coul = 1 then aux := "Noir"; else aux := "Gris";
	     result := aux;
           }
  }

  def estGris() : Integer is {
     "Inside Couleur::estGris".println();
     result := coul = 2;
  }

}

object CouleurFactory is
{  var theBlanc: Couleur := new Couleur();
   var theNoir : Couleur := new Couleur(1);
   var theGris : Couleur := new Couleur(2);

  def blanc() : Couleur := theBlanc
  def noir() : Couleur := theNoir
  def gris() : Couleur := theGris
}

/* ci-dessous on ne met pas var devant x et y sinon ca definirait deux
 * nouveaux champs qui masqueraient ceux herites de Point
 */
class PointColore(x: Integer := 0, y:Integer:= 0,
                  var coul: Couleur := CouleurFactory.blanc())
      extends Point(x, y) is {

  def couleur() : Couleur := coul

  def colore() : Integer := coul.estGris() <> 0

  override def clone() : Point /* pas PointColore. Pas de covariance ! */
  /* ci-dessous x et y sont les champs herites de Point */
       := new PointColore(x, y, coul)

  def estGris() : Integer := coul.estGris()

/* En-tete incorrect: on ne peut pas redonner ou modifier l'expression
 * d'une valeur par defaut lors d'une redefinition:
 * override def print(verbose : Integer := 0)
 * Ci-dessous verbose a une valeur par defaut implicite, définie dans la
 * methode print de Point.
 */
  override def print(verbose : Integer) is {
      if verbose then "Inside PointColore::print".println(); else { }
      super.print();  /* usage classique de super */
      this.couleur().name().println();
  }
}

class PointNoir(xc: Integer, yc:Integer)
      extends PointColore(xc, yc, CouleurFactory.noir())
      /* pas de corps de constructeur pour cette classe */
is {
  override def estGris() : Integer := 0
  override def colore() : Integer := 1
  override def couleur() : Couleur := CouleurFactory.noir()
}


class DefaultPoint() /* Parentheses obligatoires */
      extends PointColore(0, 0, CouleurFactory.blanc())
is {
  override def estGris() : Integer := 0
  override def couleur() : Couleur := CouleurFactory.blanc()
}

object Test is {
  def test(p: Point, p2: PointColore, p3: PointNoir) is {
      var c: String; var c2: String; var c3: String;
      var true: Integer := 1;
      is
      p.print(true);
      p2.print(true);
      "Appel 1: ".println();
      if p2.colore() <> 0 then c := "colore";  else c := "gris";
      "Appel 2: ".println();
      if p3.colore() <> 0 then c2 := "colore"; else c2 := "gris";
      "Appel 3: ".println();
      if p3.colore() <> 0 then c3 := "colore"; else c3 := "gris";
      "Resultats de test: ".println();
      c.print(); " ".print();
      c2.print(); " ".print();
      c3.print();
      "".println(); /* imprime une ligne vide */
  }

  def test2(p: PointColore) is {
      p.couleur().name().print();
  }
}

/* des exemples ad-hoc qui montrent d'autres aspects ... */
class A() is {
  var v : Integer := 1;
  def f() is { "A::f()\"n".print(); }
  def h(x: Integer, y : Integer := 2) : Integer := x + y
}

class A2() extends A() is {
  var v : String := "hello"; /* masque le champ v de la classe A */

  override def f() is { "A2::f()\"n".print(); }

  def g() is {
      v := "world"; /* par defaut, il s'agit du champ de A2 */
      /* this etant caste en A, le champ v en question est celui de A */
      (A this).v := 1;
      /* les deux appels doivent fournir la meme chose */
      this.f();
      (A this).f();
  }

  /* ajoute une valmeur par defaut à x qui n'en avait pas. Le parametre
   * y conserve sa valeur par defaut definie dans la methode de la superclasse
   */
  override def h(x : Integer := 3, y: Integer) : Integer := super.h(x, y)
}

{ /* Bloc qui correspond au programme principal */
  var p1: Point := new Point(1, 5, "p1");
  var p2: Point := new Point(2, 3, "p2");
  var p3 : Point := new Point(); /* utilise toutes les valeurs par defaut */
  /* Incorrect: les types ne sont pas consideres quand on decide s'il faut
   * utiliser les valeurs par defaut. Si on donne un argument, ca doit
   * forcement correspondre au premier parametre, etc. Ci-dessous, on ne
   * peut pas omettre les coordonnees et ne passer que la couleur !
   * var err : PointColore := new PointColore(new Couleur(25));
   */
  var o : PointColore := new PointColore(0, 0, (new Couleur(0)).blanc());
  var pn : PointNoir := new PointNoir(+1, -1);
  /* Incorrect: le constructeur de PointNoir n'est pas une redefinition
   * du constructeur de PointColore ou de Point. Il ne beneficie donc
   * pas de valeurs par defaut pour ses arguments (masi on aurait pu en
   * prevoir dans sa definition)
   * var pn2 : PointNoir := new PointNoir();
   */
  var dp : DefaultPoint := new DefaultPoint();
is
  p2.move(p1.getx(), p1.gety());
  o.setName("origine");
  p2.move(p1.getx()-2*5-3, p1.gety());
  o.print();
  p2.print();
  o.clone().print();
  o.clone().move(54, 36).print(true);
  O.allClones();
  /* Ne doit pas compiler car clone() renvoie statiquement un Point alors
   * que o est declare comme PointColore
   * o := o.clone();
   */
  p1 := p1.clone().move(+2, -3);
  p1.print();
  o.clone().print();
  "test(Point, PointColore, PointNoir)".println();
  unTest.test(p1, o, pn);
  "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(pn, pn, pn);
  p1 := pn; /* affectation entre pointeurs ! */
  unTest.test2(o);
  unTest.test2(pn);
  o := pn;  /* Idem : on doit avoir de la liaison dynamique ci-dessous */

  "test(PointNoir, PointNoir, PointNoir)".println();
  unTest.test(p1, o, pn);
  unTest.test2(o);
  unTest.test2(pn);
  "\nDone".println();
}
